"""
Test comparing noise floor between direct PSD generation and IQ->FFT PSD computation.

This test validates that the transponder noise floor has the same spectral shape
and power level in both the frequency-domain PSD generation and the time-domain
IQ generation followed by FFT analysis.
"""

import pytest
import numpy as np
from scipy import signal
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend for testing
import matplotlib.pyplot as plt
from satellite_downlink_simulator.objects.transponder import Transponder
from satellite_downlink_simulator.simulation.psd import generate_psd
from satellite_downlink_simulator.simulation.iq import generate_iq


def compute_psd_from_iq(iq_data, sample_rate_hz, center_frequency_hz, nperseg=1024):
    """
    Compute PSD from IQ data using Welch's method.

    Parameters
    ----------
    iq_data : np.ndarray
        Complex IQ samples
    sample_rate_hz : float
        Sample rate in Hz
    center_frequency_hz : float
        Center frequency in Hz (for absolute frequency output)
    nperseg : int
        Length of each segment for Welch's method

    Returns
    -------
    frequencies : np.ndarray
        Frequency array in Hz (absolute frequencies)
    psd_dbm_per_hz : np.ndarray
        PSD in dBm/Hz
    """
    # Use Welch's method to estimate PSD
    frequencies, psd_watts_per_hz = signal.welch(
        iq_data,
        fs=sample_rate_hz,
        nperseg=nperseg,
        scaling='density',
        return_onesided=False
    )

    # Shift frequencies to be centered at 0
    frequencies = np.fft.fftshift(frequencies)
    psd_watts_per_hz = np.fft.fftshift(psd_watts_per_hz)

    # Convert to absolute frequencies
    frequencies = frequencies + center_frequency_hz

    # Convert to dBm/Hz
    psd_dbm_per_hz = 10 * np.log10(psd_watts_per_hz * 1000)

    return frequencies, psd_dbm_per_hz


class TestNoiseFloorComparison:
    """Test noise floor comparison between direct generation and IQ->FFT."""

    def test_noise_floor_shape_and_power_match(self, simple_transponder, plots_dir, attach_plot):
        """
        Test that noise floor shape and power match between PSD and IQ methods.

        This test creates an empty transponder (no carriers) and compares the
        noise floor generated by:
        1. Direct PSD generation (frequency domain)
        2. IQ generation + FFT (time domain)

        Both the spectral shape and integrated power should match.
        """
        # Use empty transponder (no carriers) - just noise
        assert len(simple_transponder.carriers) == 0, "Transponder should have no carriers"

        # Generate direct PSD
        rbw_hz = 50e3  # 50 kHz RBW
        vbw_hz = 5e3   # 5 kHz VBW
        freq_direct, psd_direct, metadata_direct = generate_psd(
            simple_transponder,
            rbw_hz=rbw_hz,
            vbw_hz=vbw_hz,
            add_noise=False  # Disable measurement noise for cleaner comparison
        )

        # Generate IQ data with longer duration for better frequency resolution
        duration_s = 0.1  # 100 ms
        iq_data, metadata_iq = generate_iq(
            simple_transponder,
            duration_s=duration_s,
            seed=42  # Set seed for reproducibility
        )

        # Compute PSD from IQ using Welch's method
        # Use larger nperseg for better frequency resolution and averaging
        nperseg = min(8192, len(iq_data) // 8)
        freq_iq, psd_iq = compute_psd_from_iq(
            iq_data,
            metadata_iq.sample_rate_hz,
            metadata_iq.center_frequency_hz,
            nperseg=nperseg
        )

        # Extract the portion of IQ-derived PSD that corresponds to transponder bandwidth
        t_lower = simple_transponder.lower_frequency_hz
        t_upper = simple_transponder.upper_frequency_hz
        iq_mask = (freq_iq >= t_lower) & (freq_iq <= t_upper)
        freq_iq_transponder = freq_iq[iq_mask]
        psd_iq_transponder = psd_iq[iq_mask]

        # Interpolate IQ-derived PSD to match direct PSD frequencies
        psd_iq_interp = np.interp(freq_direct, freq_iq_transponder, psd_iq_transponder)

        # Compare spectral shapes (in dB domain)
        diff_db = psd_direct - psd_iq_interp
        rms_error = np.sqrt(np.mean(diff_db ** 2))

        print(f"\n=== Noise Floor Comparison ===")
        print(f"Transponder bandwidth: {simple_transponder.bandwidth_hz / 1e6:.1f} MHz")
        print(f"Noise power density: {simple_transponder.noise_power_density_watts_per_hz:.3e} W/Hz")
        print(f"Direct PSD points: {len(freq_direct)}")
        print(f"IQ->FFT PSD points (total): {len(freq_iq)}")
        print(f"IQ->FFT PSD points (transponder BW): {len(freq_iq_transponder)}")
        print(f"Sample rate: {metadata_iq.sample_rate_hz / 1e6:.2f} MHz")
        print(f"\nDirect PSD range: {np.min(psd_direct):.1f} to {np.max(psd_direct):.1f} dBm/Hz")
        print(f"IQ PSD range (interp): {np.min(psd_iq_interp):.1f} to {np.max(psd_iq_interp):.1f} dBm/Hz")
        print(f"Mean difference: {np.mean(diff_db):.3f} dB")
        print(f"RMS error: {rms_error:.3f} dB")

        # Convert to linear scale for power integration
        psd_direct_linear = 10 ** (psd_direct / 10) / 1000  # dBm to W/Hz
        psd_iq_interp_linear = 10 ** (psd_iq_interp / 10) / 1000

        # Integrate power
        power_direct = np.trapezoid(psd_direct_linear, freq_direct)
        power_iq = np.trapezoid(psd_iq_interp_linear, freq_direct)

        # Expected power
        expected_power = simple_transponder.noise_power_density_watts_per_hz * simple_transponder.bandwidth_hz

        print(f"\nExpected noise power: {expected_power:.6e} W")
        print(f"Direct PSD integrated power: {power_direct:.6e} W")
        print(f"IQ->FFT integrated power: {power_iq:.6e} W")
        print(f"Direct/Expected ratio: {power_direct / expected_power:.3f}")
        print(f"IQ/Expected ratio: {power_iq / expected_power:.3f}")
        print(f"IQ/Direct ratio: {power_iq / power_direct:.3f}")

        # Generate plot if HTML report requested
        if plots_dir is not None:
            fig, axes = plt.subplots(2, 1, figsize=(12, 10))

            # Convert frequencies to MHz offset from center for plotting
            center_freq = simple_transponder.center_frequency_hz
            freq_offset_direct = (freq_direct - center_freq) / 1e6
            freq_offset_iq = (freq_iq_transponder - center_freq) / 1e6

            # Top plot: PSD comparison
            axes[0].plot(freq_offset_direct, psd_direct, 'b-', label='Direct PSD', linewidth=2)
            axes[0].plot(freq_offset_direct, psd_iq_interp, 'r-', label='IQ→FFT PSD (interpolated)', alpha=0.7, linewidth=2)
            axes[0].axhline(y=10*np.log10(simple_transponder.noise_power_density_watts_per_hz * 1000),
                           color='g', linestyle='--', label=f'Expected N₀ = {10*np.log10(simple_transponder.noise_power_density_watts_per_hz * 1000):.1f} dBm/Hz')
            axes[0].set_xlabel('Frequency Offset from Center (MHz)')
            axes[0].set_ylabel('PSD (dBm/Hz)')
            axes[0].set_title('Noise Floor Comparison: Direct PSD vs IQ→FFT')
            axes[0].legend()
            axes[0].grid(True, alpha=0.3)

            # Bottom plot: Difference
            axes[1].plot(freq_offset_direct, diff_db, 'k-', linewidth=1)
            axes[1].axhline(y=0, color='r', linestyle='--', linewidth=2)
            axes[1].fill_between(freq_offset_direct, -3, 3, alpha=0.2, color='green', label='±3 dB tolerance')
            axes[1].set_xlabel('Frequency Offset from Center (MHz)')
            axes[1].set_ylabel('Difference (dB)')
            axes[1].set_title(f'Direct - IQ PSD Difference (RMS error: {rms_error:.3f} dB)')
            axes[1].legend()
            axes[1].grid(True, alpha=0.3)

            plt.tight_layout()
            plot_path = plots_dir / 'noise_floor_shape_and_power.png'
            fig.savefig(plot_path, dpi=150, bbox_inches='tight')
            plt.close(fig)
            attach_plot(plot_path)

        # Assertions:
        # 1. RMS error should be small (within a few dB)
        #    Note: Some difference is expected due to statistical estimation vs analytical
        assert rms_error < 5.0, f"RMS error {rms_error:.3f} dB exceeds 5 dB threshold"

        # 2. Integrated powers should match within 20%
        power_ratio = power_iq / power_direct
        assert 0.8 < power_ratio < 1.2, \
            f"Power ratio {power_ratio:.3f} outside acceptable range [0.8, 1.2]"

        # 3. Both should be close to expected noise power (within factor of 2)
        #    The direct PSD should be very close, IQ might have some variance
        assert 0.5 < power_direct / expected_power < 2.0, \
            f"Direct PSD power ratio {power_direct / expected_power:.3f} outside [0.5, 2.0]"
        assert 0.5 < power_iq / expected_power < 2.0, \
            f"IQ PSD power ratio {power_iq / expected_power:.3f} outside [0.5, 2.0]"

    def test_noise_floor_shape_detailed(self, simple_transponder, plots_dir, attach_plot):
        """
        Detailed test of noise floor spectral shape matching.

        This test examines the shape of the noise floor more carefully by
        comparing normalized PSD profiles (shape independent of absolute power).
        """
        # Generate direct PSD
        rbw_hz = 50e3
        vbw_hz = 5e3
        freq_direct, psd_direct, _ = generate_psd(
            simple_transponder,
            rbw_hz=rbw_hz,
            vbw_hz=vbw_hz,
            add_noise=False
        )

        # Generate IQ data
        duration_s = 0.1
        iq_data, metadata_iq = generate_iq(
            simple_transponder,
            duration_s=duration_s,
            seed=42
        )

        # Compute PSD from IQ
        nperseg = min(8192, len(iq_data) // 8)
        freq_iq, psd_iq = compute_psd_from_iq(
            iq_data,
            metadata_iq.sample_rate_hz,
            metadata_iq.center_frequency_hz,
            nperseg=nperseg
        )

        # Extract transponder bandwidth
        t_lower = simple_transponder.lower_frequency_hz
        t_upper = simple_transponder.upper_frequency_hz
        iq_mask = (freq_iq >= t_lower) & (freq_iq <= t_upper)
        freq_iq_transponder = freq_iq[iq_mask]
        psd_iq_transponder = psd_iq[iq_mask]

        # Interpolate
        psd_iq_interp = np.interp(freq_direct, freq_iq_transponder, psd_iq_transponder)

        # Normalize both PSDs by their maximum value (to compare shapes)
        psd_direct_normalized = psd_direct - np.max(psd_direct)
        psd_iq_normalized = psd_iq_interp - np.max(psd_iq_interp)

        # Compare normalized shapes
        shape_diff = np.abs(psd_direct_normalized - psd_iq_normalized)
        max_shape_diff = np.max(shape_diff)
        mean_shape_diff = np.mean(shape_diff)

        print(f"\n=== Normalized Shape Comparison ===")
        print(f"Max shape difference: {max_shape_diff:.3f} dB")
        print(f"Mean shape difference: {mean_shape_diff:.3f} dB")

        # Generate plot if HTML report requested
        if plots_dir is not None:
            fig, axes = plt.subplots(2, 1, figsize=(12, 10))

            # Convert frequencies to MHz offset from center for plotting
            center_freq = simple_transponder.center_frequency_hz
            freq_offset_direct = (freq_direct - center_freq) / 1e6

            # Top plot: Normalized PSDs
            axes[0].plot(freq_offset_direct, psd_direct_normalized, 'b-', label='Direct PSD (normalized)', linewidth=2)
            axes[0].plot(freq_offset_direct, psd_iq_normalized, 'r-', label='IQ→FFT PSD (normalized)', alpha=0.7, linewidth=2)
            axes[0].axhline(y=0, color='g', linestyle='--', label='Peak = 0 dB (normalized)')
            axes[0].set_xlabel('Frequency Offset from Center (MHz)')
            axes[0].set_ylabel('Normalized PSD (dB relative to peak)')
            axes[0].set_title('Normalized Noise Floor Shape Comparison')
            axes[0].legend()
            axes[0].grid(True, alpha=0.3)
            axes[0].set_ylim(-15, 2)

            # Bottom plot: Absolute difference
            axes[1].plot(freq_offset_direct, shape_diff, 'k-', linewidth=1)
            axes[1].axhline(y=mean_shape_diff, color='orange', linestyle='--', label=f'Mean = {mean_shape_diff:.3f} dB')
            axes[1].axhline(y=3, color='r', linestyle=':', alpha=0.5, label='3 dB threshold')
            axes[1].set_xlabel('Frequency Offset from Center (MHz)')
            axes[1].set_ylabel('Absolute Difference (dB)')
            axes[1].set_title(f'Normalized Shape Difference (Max: {max_shape_diff:.3f} dB)')
            axes[1].legend()
            axes[1].grid(True, alpha=0.3)

            plt.tight_layout()
            plot_path = plots_dir / 'noise_floor_normalized_shape.png'
            fig.savefig(plot_path, dpi=150, bbox_inches='tight')
            plt.close(fig)
            attach_plot(plot_path)

        # The normalized shapes should match closely
        assert max_shape_diff < 10.0, \
            f"Max normalized shape difference {max_shape_diff:.3f} dB exceeds 10 dB"
        assert mean_shape_diff < 3.0, \
            f"Mean normalized shape difference {mean_shape_diff:.3f} dB exceeds 3 dB"

    def test_noise_floor_with_different_sample_rates(self, simple_transponder, plots_dir, attach_plot):
        """
        Test that noise floor matches even with different sample rates.

        This tests the edge case where sample rate is very close to bandwidth
        (minimal oversampling).
        """
        # Generate direct PSD
        rbw_hz = 50e3
        vbw_hz = 5e3
        freq_direct, psd_direct, _ = generate_psd(
            simple_transponder,
            rbw_hz=rbw_hz,
            vbw_hz=vbw_hz,
            add_noise=False
        )

        # Generate IQ with minimal oversampling (1.1x bandwidth)
        sample_rate_hz = 1.1 * simple_transponder.bandwidth_hz
        duration_s = 0.1
        iq_data, metadata_iq = generate_iq(
            simple_transponder,
            duration_s=duration_s,
            sample_rate_hz=sample_rate_hz,
            seed=42
        )

        # Compute PSD from IQ
        nperseg = min(4096, len(iq_data) // 8)
        freq_iq, psd_iq = compute_psd_from_iq(
            iq_data,
            metadata_iq.sample_rate_hz,
            metadata_iq.center_frequency_hz,
            nperseg=nperseg
        )

        # Extract transponder bandwidth
        t_lower = simple_transponder.lower_frequency_hz
        t_upper = simple_transponder.upper_frequency_hz
        iq_mask = (freq_iq >= t_lower) & (freq_iq <= t_upper)
        freq_iq_transponder = freq_iq[iq_mask]
        psd_iq_transponder = psd_iq[iq_mask]

        # Interpolate
        psd_iq_interp = np.interp(freq_direct, freq_iq_transponder, psd_iq_transponder)

        # Compare
        psd_direct_linear = 10 ** (psd_direct / 10) / 1000
        psd_iq_interp_linear = 10 ** (psd_iq_interp / 10) / 1000

        power_direct = np.trapezoid(psd_direct_linear, freq_direct)
        power_iq = np.trapezoid(psd_iq_interp_linear, freq_direct)

        power_ratio = power_iq / power_direct

        print(f"\n=== Low Oversampling Test (1.1x BW) ===")
        print(f"Sample rate: {metadata_iq.sample_rate_hz / 1e6:.2f} MHz")
        print(f"Power ratio: {power_ratio:.3f}")

        # Generate plot if HTML report requested
        if plots_dir is not None:
            fig, ax = plt.subplots(figsize=(12, 6))

            # Convert frequencies to MHz offset from center for plotting
            center_freq = simple_transponder.center_frequency_hz
            freq_offset_direct = (freq_direct - center_freq) / 1e6

            # Plot PSDs
            ax.plot(freq_offset_direct, psd_direct, 'b-', label='Direct PSD', linewidth=2)
            ax.plot(freq_offset_direct, psd_iq_interp, 'r-', label=f'IQ→FFT PSD (1.1× oversample)', alpha=0.7, linewidth=2)
            ax.axhline(y=10*np.log10(simple_transponder.noise_power_density_watts_per_hz * 1000),
                      color='g', linestyle='--', label=f'Expected N₀')
            ax.set_xlabel('Frequency Offset from Center (MHz)')
            ax.set_ylabel('PSD (dBm/Hz)')
            ax.set_title(f'Noise Floor with Low Oversampling (Sample Rate: {metadata_iq.sample_rate_hz/1e6:.2f} MHz, Power Ratio: {power_ratio:.3f})')
            ax.legend()
            ax.grid(True, alpha=0.3)

            plt.tight_layout()
            plot_path = plots_dir / 'noise_floor_low_oversampling.png'
            fig.savefig(plot_path, dpi=150, bbox_inches='tight')
            plt.close(fig)
            attach_plot(plot_path)

        # Should still match reasonably well even with minimal oversampling
        assert 0.7 < power_ratio < 1.3, \
            f"Power ratio {power_ratio:.3f} with low oversampling outside [0.7, 1.3]"
